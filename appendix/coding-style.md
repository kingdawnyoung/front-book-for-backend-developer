# 编码风格

## 基本

1. 变量在声明后才可以使用
1. 多个变量同时声明，使用逗号( `,` )隔开，最后一个变量后加分号(`;`)；每个变量单独声明时，每个变量独立一行;

```js
let foo, bar;

let foo;
let bar;
```

1. 变量命名应当采用驼峰命名格式，普通变量的第一个单词应当是一个名词，函数名第一个单词应当是动词

```js
let dialogShow = true;

function search() {
  // do something
}
```
1. 初始化一个值尽量使用字面量
```js
// good
let str = '',
  obj = {},
  arr = [],
  bool = true;

// bad
let str = new String(),
  obj = new Object(),
  arr = new Array(),
  bool = new Boolean()
```
1. 函数声明
   * 尽量使用声明式，因为这样函数会提升，保证在使用时就已经声明
   * 函数名和开始圆括号之间不应当有空格。
   * 结束的圆括号和右边的大括号之间应该留一个空格。
   * 右侧的大括号应当同function关键字保持同一行。
   * 开始和结束括号之间不应该有空格。
   * 参数名之间应当在逗号之后保留一个空格。
   * 函数体应当保持一级缩进。
    ```js
    function fn() {
      // do something
    }
    ```
1. 多行对象声明
   * 起始左大括号应当同表达式保持同一行。
   * 每个属性的名值对应当保持一个缩进（两个空格），第一个属性应当在左大括号后另起一行。
   * 每个属性的名值对应当使用不含引号的属性名，其后紧跟一个冒号，而后插入一个空格，再加上值
   * 倘若属性值是函数类型，函数体应当在属性名之下另起一行
   * 结束的右大括号应当独占一行。
   * 对象作为函数参数时，起始大括号应当同函数名一行
    ```js
    let obj = {
      foo: 'foo',
      bar: 'bar',
      fn: function() {
        // do something
      },
    };
    ```

1. 严格模式应当仅限于在函数内部使用 `'use strict'`
    ```js
   (function(){
     'use strict'
   })();
    ```

1. 使用两个空格替代制表符的缩进，保证在不同编辑器有相同表现
1. 运算符前后必须使用一个空格来保持表达式的整洁
1. 当使用括号时，紧接左括号之后和紧接右括号之前不应该有空格
   ```js
   if (a & (b & c) > d) {
     // do something
   }
   ```
1. 复合语句，使用大括号括起来的语句列表，比如`if`、`for`语句
   * 大括号之间的语句比外层多缩进一层
   * 开始的大括号应当在复合语句所在行的末尾；结尾的大括号独占一行，并与复合语句的开始保持对齐
   * 诸如`if`、`for`等控制结构的语句都需要用大括号括起来，即使仅有一条语句
   ```js
   for(let i = 0, len = arr.length; i < len; i++) {
     // do something
   }
   ```
1. 使用 `===` 表示用于判断等于，使用 `!==` 用于判断不等
   ```js
   // good
   a === b;
   b !== c;

   // bad
   a == b;
   b != c;
   ```
1. 三元操作符应当仅仅用在条件赋值语句中，不要作为`if`语句的替代品
   ```js
   // good
   let a = condition ? c : d;

   // bad
   let a = condition ? fn1() : fn2();
   ```
1. 每一行一条语句，所有简单的语句都应该以分号（;）结束
1. 避免使用 `for...in` 遍历数组，推荐使用 `for(;;)` 遍历数组
1. 避免在非函数的代码块中声明函数函数
1. 使用 `try...catch` 时尽量对捕获的异常进行处理

1. 避免使用 `eval`，避免使用 `with` 语句
1. 避免在原生数据类型扩展属性和方法

1. 注释是对代码的说明，务必保证注释与代码的相关性
1. **不可以在注释里写不必要的代码，直接删除**
1. 在注释之前尽量留白一行
1. 使用独占一行的注释，来解释下一行代码
1. 对于代码行尾的单行注释的情况，应确保代码结尾同注释符之间至少一个缩进
1. 注释符和注释内容之间保持一个空格
1. 多行注释使用`/*...*/`形式，避免使用多个`//`
1. 多行注释符首行留空，每行`*`和注释内容之间保持一个空格
1. 使用 `/*...*/` 对方法的定义进行注解，可以适当添加入参（@param）、出参（@returns）等说明。更多说明标签请参考JSDoc
   ```js
   // good
    /*
    * 方法
    * @param {string} arg1 参数1
    * @param {string} arg2 参数2
    */
    function fn(arg1, arg2) {
      // do something
    }

   // bad
   // 方法
   function fn(arg1, arg2) {
     // do something
   }
   ```

1. 尽量使用原生自带的属性和方法
   ```js
   _.find(arr, item => {...});

   // good
   arr.find(item => {...});
   ```
1. 尽量使用标准通用的属性和方法
   ```js
   // bad
   str[0];

   // good
   str.charAt(0)
   ```


## es6

1. **使用`let`替代`var`**
1. **常量使用`const`**

1. 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。
1. 尽量使用字符串模版进行字符串的拼接而不是加号，方便阅读和修改
   ```js
   // bad
   '字符串' + a + b + c;

   // good
   `字符串${a}${b}${c}`;
   ```
1. 使用数组成员对变量赋值时，优先使用解构赋值。
   ```js
   // bad
   let a = arr[0],
     b = arr[1];

   // good
   let [a, b] = arr;
   ```
1. 函数的参数如果是对象，优先使用解构赋值。
   ```js
   function fn(arg) {
     let a = arg.a,
       b = arg.b;
   }

   // good
   function fn({a, b}) {
     // do something
   }
   ```
1. 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。

1. 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾
   ```js
   let obj = {
     foo: 'foo',
     bar: 'bar',
     fn: function() {
       // do something
     },
   };
   ```

1. 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用`Object.assign`方法。
1. 浅拷贝数组使用（...），不要用`Object.assign`
   ```js
   let source = { foo: "foo", bar: "bar" },
     target = {...source};
   ```
1. 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。
1. **对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写**
   ```js
   let foo = "foo",
     bar = "bar";

   let obj = {
     foo,
     bar,
     fn() {
       // do something
     },
   };
   ```

1. 使用扩展运算符（...）拷贝数组
1. 使用 `Array.from` 方法，将类类数组的对象转为数组。

1. **立即执行函数可以写成箭头函数的形式。**
1. **需要使用函数表达式的场合，尽量用箭头函数代替。这样更简洁，而且绑定了 `this`。**
   ```js
   arr.map(item => {...});
   ```
1. 箭头函数取代 `.bind`，**不应再用 self/_this/that 绑定 this**。
   ```js
   // bad
   arr.map(function (item) {
     // do something
   }.bind(arr));

   // bad
   const self = this;
   arr.map(function() {
     this.method
   });

   // good
   arr.map(item => {...});
   ```
1. 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。
1. 所有配置项都应该集中在一个对象，**放在最后一个参数**，布尔值不可以直接作为参数。
1. 不要在函数体内使用 `arguments` 变量，使用 `rest` 运算符（...）代替。
1. 使用默认值语法设置函数参数的默认值。

1. 只有模拟现实世界的实体对象时，才使用 `Object`。如果只是需要 `key: value` 的数据结构，使用 `Map` 结构。

1. 总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。
1. 使用`extends`实现继承，因为这样更简单，不会有破坏`instanceof`运算的危险。

1. 首先，`Module` 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用`import`取代`require`。
1. 使用`export`取代`module.exports`。
1. 不要在模块输入中使用通配符(*)。
   ```js
   // bad
   import * as param from "./module";
   param.foo;
   param.bar;

   // good
   import { foo, bar } from "./module";
   ```
1. 如果模块默认输出一个函数，函数名的首字母应该小写。
1. 如果模块默认输出一个对象，对象名的首字母应该大写。

## 样式
1. 一条css规则由选择器和声明构成，每条规则间留白一行。
1. 鉴于样式的渲染原理，构成选择器元素尽量使用`类选择器`，不推荐使用使用`标签选择器`、`属性选择器`。
1. 选择器在分组时，一组选择器独自放一行。
   ```css
   /* bad */
   .dialog-caption, .dialog-body {

   } 

   /* good */
   .dialog-caption,
   .dialog-body {

   }
   ```
1. 构成选择器的元素不宜超过**3**个。
1. 类选择器命名采用短横线隔开单词形式，俗称`烤串命名法`，每个单词均为小写。(该条不适用于BEM命名法)
1. id选择器命名使用驼峰命名法。
1. 选择器应使用有意义有组织并有明确目的的名称，避免使用表现形式的词汇。
    ```css
    /* bad */
    .top {

    }

    /* good */
    .caption {

    }
    ```
1. 选择器在表示状态时，一般以`is-`开头，比如`is-show`。
1. css声明包含在一对花括号内`{}`, 起始花括号最后一组选择器的末尾, 与选择器间留有一个空格；结尾花括号独占一行，与选择器起始位置对齐。
1. css声明在与最后一组选择器另起一行并缩进一个层级；每条声明独占一行，起始位置对齐，以分号`;`结尾。
1. css声明由 `属性: 值` 构成；`属性`后紧跟冒号`:`，冒号和值之间留有一个空格。
1. 相关属性的声明保持在一组，以定位属性举例:
   ```css
   .ad {
     position: fixed;
     top: 10px;
     right: 10px;
     bottom: 10px;
     left: 10px;
     
     display: flex;
   }
   ```
1. css声明推荐使用简写形式，但不宜滥用, 常用简写属性`margin`、 `padding`、 `font`、 `background`、`border`、 `border-radius`，`transition`。(该条不适用于rn和weex开发)
1. css声明值为`0`时可以省略单位；如果值为零点几时可以省略零，比如`.1rem`;
1. css声明值尽量不要加`!important`，不便样式覆盖。

## 6大原则
1. 开闭原则
1. 里氏代换原则
1. 依赖倒转原则
1. 接口隔离原则
1. 迪米特法则
1. 合成复用原则

## 功能
1. 函数体不宜过大，超过一屏的函数应拆分为多个函数。
1. 调用接口时尽量封装成`promise`对象，方便重复使用。
1. 涉及分页接口调用，`pageIndex`表示页码，`pageSize`表示每页数量，`hasMore`表示是否还有数据。
1. 对于接口异常返回一定要进行处理，使用`promise`封装时用`reject`抛出异常原因。
1. 定时器开启后放到数组里，这样可以避免定时器变量被覆盖导致的无法释放的问题。
1. url传参推荐使用驼峰命名法，比如`orderId=123&from=welfare`。
1. 涉及同类型逻辑判断优先考虑使用对象形式取值
   ```css
   const condition = 1;
   left result = ''

   // bad
   if(condition === 1) {
     result = 'a';
   } else if(condition === 2) {
     result = 'b';
   } else {
     result = 'c';
   }

   // good
   result = ({1: 'a', 2: 'b', 3: 'c'})[condition] || 'c';
   ```
1. 对象和数组在使用前一定要进行非空判断，否则可能会导致小程序的整体崩溃。
   ```js
   // 简单的对象数组为空的处理方式，具体业务还需具体处理

   const obj = null;
   (obj || {})['a'];

   const arr = null;
   (arr || []).length ? arr[0] : '';
   ```
1. 尽量不要在循环中使用组件，否则会增加`vue`等对组件的管理负担。
1. 提交表单时加`loading`避免重复提交; 有时为了防止重复点击可以在点击事件处理上加`throttle`节流。







